# 绑定

　　诸如本地变量、实例变量、`self`一类的实体……或者说所有于对象绑定的名称。我们把他们称为**绑定（bindings）**。

　　下面内容摘自紫苏的博客，[该文](http://szsu.wordpress.com/2010/09/04/binding/)对我们的讨论很有意义。

　　在计算机科学中，**“绑定”（Binding）**一词是指一个更复杂、更大型的物件的引用的创建。例如当我们编写了一个函数，这个函数名就绑定了该函数本体，我们可以通过函数名来引用并调用该函数，这被称为名称绑定；又如当Ruby通过API去调用了C语言写的库函数时，这就是一个语言绑定；再如面向对象语言中的方法调度`obj.method`，这也是一个名称绑定，它会根据接收者`obj`具体的对象类型来确定应该引用哪个对象类型的`method`方法，而如果`obj`在编译时就能确定，那便可称之为**静态绑定（早绑定）**，早期的静态类型语言（如C）使用的是早绑定；如果obj在运行时才能确定，那便可称为**动态绑定（迟绑定）**，动态类型语言（如Ruby）使用的是迟绑定，而有些语言则同时支持早绑定和迟绑定，如C++的虚函数使用迟绑定，普通函数则使用早绑定。

　　在Ruby中，`Kernel`有一个方法`binding`，它返回一个Binding类型的对象。这个`Binding`对象就是我们这里说的绑定，它封装了当前执行上下文中的所有绑定（变量、方法、语句块、`self`的名称绑定），而这些绑定直接决定了面向对象语言中的执行环境。比如，当我们调用`p`时，实际上是进行了`self`和`p`的绑定，而`p`具体是哪个方法，是由`self`的类型来决定的，如果我们在顶层，而`Kernel#p`又没有被重写，那`p`就是一个用来显示对象细节的方法。可以说有了一个绑定的列表，我们就有了一个完整的面向对象上下文的拷贝，就好比上帝在12分37秒复制了一份世界，而这个世界与原本世界的环境一模一样，既有这朵花，又有那株草。Ruby的Binding对象的概念和 Continuation有共通之处，但Continuation主要用于实际堆、栈内存的环境跳转，而Binding则比较高层。

　　这个Binding对象有什么用？主要是用于`eval`这个函数。`eval`的第一个参数是需要`eval`的一段脚本字符串，而第二个可选参数则接受一个`Binding`对象。当指定了`Binding`时，`eval`会在传递给它的`Binding`所封装的执行环境里执行脚本，否则是在调用者的执行环境里执行。我们可以通过这个机制来进行一些不同上下文之间的通信，或者是在一个上下文即将被销毁之前保存该上下文环境以留他用，如：

```ruby
def foo
  bar = 'baz'
  return binding
end

eval('p bar', foo)
```

　　这里我们通过`foo`返回的`Binding`获取到了局部上下文销毁前的局部变量`bar`的值，而在不使用`binding`的情况下，局部变量`bar`在`foo`外层是不可见的。

　　最后，Ruby有一个预定义的常量：`TOPLEVEL_BINDING`，它指向一个封装了顶层绑定的对象，通过它我们可以在其它上下文中通过`eval`在顶层上下文环境中执行脚本。
